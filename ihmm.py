from __future__ import division
from collections import defaultdict
import math
import numpy as np

__author__ = 'jpaton'

burn_in_period = 1000

class Symbol(object):
    _next_id = 0
    def __init__(self, id=None):
        if id == None:
            id = Symbol._next_id
            Symbol._next_id += 1
        self.id = id

    def __repr__(self):
        return repr(self.id)

class StateFactory(object):
    def __init__(self, alpha, beta, gamma, beta_e, gamma_e):
        self.alpha = alpha
        self.beta = beta
        self.gamma = gamma
        self.beta_e = beta_e
        self.gamma_e = gamma_e
        self.next_id = 0

    def get_state(self):
        ret = StateFactory.State(self.alpha,
                                  self.beta_e,
                                  self.gamma_e,
                                  self.next_id)
        self.next_id += 1
        return ret

    def generate_state(self, prev_state, states, n_o):
        """
        Generate another state given the previous state.

        Automatically increments n_o[state] if new state is generated by the oracle.
        """
        pseudo_state = self.get_state()
        pseudo_states = states + [pseudo_state]
        denominator = prev_state.total_transitions + self.beta
        def p_nonoracle(state):
            if state == pseudo_state:
                return self.beta / denominator
            return prev_state.transitions[state] / denominator
        probs = map(p_nonoracle, pseudo_states)
        index = np.random.multinomial(1, probs).tolist().index(1)
        if index == len(states):
            # go to oracle
            def p_oracle(state):
                oracle_denom = np.sum(n_o.values()) + self.gamma
                if state == pseudo_state:
                    return self.gamma / oracle_denom
                return n_o[state] / oracle_denom
            probs = map(p_oracle, pseudo_states)
            index = np.random.multinomial(1, probs).tolist().index(1)
            if index == len(states):
                # new state
                n_o[pseudo_state] = 1
                prev_state.transitions[pseudo_state] = 1
                states.append(pseudo_state)
                return pseudo_state
            else:
                n_o[states[index]] += 1
        prev_state.transitions[states[index]] += 1
        return states[index]

    class State(object):
        def __init__(self, alpha, beta_e, gamma_e, id):
            self.transitions = defaultdict(lambda: 0)
            self.emissions = defaultdict(lambda: 0)
            self.beta_e = beta_e
            self.gamma_e = gamma_e
            self.id = id
            self.transitions[self] = alpha

        def __repr__(self):
            return repr(self.id)

        @property
        def total_emissions(self):
            # TODO: memoize this
            return np.sum(self.emissions.values())

        @property
        def total_transitions(self):
            # TODO: memoize
            return np.sum(self.transitions.values())

        def generate_emission(self, symbols, m_o):
            """
            Automatically increments m_o[emission] if emission is generated by the oracle
            """
            pseudo_symbol = Symbol()
            pseudo_symbols = symbols + [pseudo_symbol]
            denominator = self.total_emissions + self.beta_e
            def p_nonoracle(symbol):
                if symbol == pseudo_symbol:
                    return self.beta_e / denominator
                return self.emissions[symbol] / denominator
            probs = map(p_nonoracle, pseudo_symbols)
            index = np.random.multinomial(1, probs).tolist().index(1)
            if index == len(symbols):
                # go to oracle
                def p_oracle(symbol):
                    oracle_denom = np.sum(m_o.values()) + self.gamma_e
                    if symbol == pseudo_symbol:
                        return self.gamma_e / oracle_denom
                    return m_o[symbol] / oracle_denom
                probs = map(p_oracle, pseudo_symbols)
                index = np.random.multinomial(1, probs).tolist().index(1)
                if index == len(symbols):
                    m_o[pseudo_symbol] = 1
                    symbols.append(pseudo_symbol)
                    self.emissions[pseudo_symbol] = 1
                    return pseudo_symbol
                else:
                    m_o[symbols[index]] += 1
            self.emissions[symbols[index]] += 1
            return symbols[index]

class Emission(object):
    def __init__(self, symbol, is_oracle=False):
        self.symbol = symbol
        self.is_oracle = is_oracle

    def __repr__(self):
        return repr(self.symbol)

class EmissionSequence(list):
    pass

class StateSequence(list):
    pass

class Sequence(object):
    def __init__(self, states=StateSequence(), emissions=EmissionSequence()):
        self.emissions = emissions
        self.states = states

class SequenceFactory(object):
    def __init__(self, state_factory):
        self.state_factory = state_factory

    def create_sequence(self, n):
        """
        Creates and returns a Sequence of length n given the parameters
        """
        m_o = defaultdict(lambda: 0)                # number of times emission oracle has generated each symbol
        n_o = defaultdict(lambda: 0)                # number of times state oracle has generated each state
        state_sequence = StateSequence()
        emissions = EmissionSequence()
        symbols = list()
        states = list()
        prev_state = self.state_factory.get_state()
        states.append(prev_state)
        n_o[prev_state] = 1
        state_sequence.append(prev_state)
        emissions.append(prev_state.generate_emission(symbols, m_o))
        for i in range(1, n):
            # sample a new state
            next_state = self.state_factory.generate_state(prev_state, states, n_o)
            next_emission = next_state.generate_emission(symbols, m_o)
            state_sequence.append(next_state)
            emissions.append(next_emission)
            prev_state = next_state
        return state_sequence, emissions

def draw_categorical(seq, probs):
    index = np.random.multinomial(1, probs).tolist().index(1)
    return list(seq)[index]

class SequenceMember(object):
    def __init__(self, state, emission, state_oracle, emission_oracle):
        self.state = state
        self.emission = emission
        self.state_oracle = state_oracle
        self.emission_oracle = emission_oracle

class Sequence(list):
    @property
    def state_sequence(self):
        return map(lambda x: x.state, self)

    @property
    def emission_sequence(self):
        return map(lambda x: x.emission, self)

def ihmm_prob_state(new_stat, prev_state, next_state, emission, n, m):
    pass

def metropolis(p, cur, seq):
    new = draw_categorical(seq, [1 / len(seq) for i in seq])
    if p(cur) == 0:
        return new
    r = np.min([p(new) / p(cur), 1])
    if np.random.binomial(1, r):
        return new
    else:
        return cur

def learn_state_sequence(emissions, K=20):
    # first, initialize sequence
    alpha, beta, gamma, beta_e, gamma_e = 1, 5, 5, 5, 5
    state_factory = StateFactory(alpha, beta, gamma, beta_e, gamma_e)
    states = [state_factory.get_state() for i in range(K)]
    sequence = Sequence()   # list of SequenceMember objects
    for symbol in emissions:
        state = draw_categorical(states, [1/K for state in states])
        # TODO: think: are the next two lines okay?
        state_oracle = draw_categorical([True, False], [0.5, 0.5])
        emission_oracle = draw_categorical([True, False], [0.5, 0.5])
        sequence.append(SequenceMember(state, symbol, state_oracle, emission_oracle))

    # now that we have our initial state sequence, start Gibbs sampling to improve
    while True:
        state_factory = StateFactory(alpha, beta, gamma, beta_e, gamma_e)
        m = defaultdict(lambda: defaultdict(lambda: 0)) # m[i][j] = number of times state i
                                                        # has emitted symbol j
        n = defaultdict(lambda: defaultdict(lambda: 0)) # n[i][j] = number of times state i
                                                        # has transitioned to state j
        m_o = defaultdict(lambda: 0) # m_o[i] = number of times oracle has generated
                                     # emission i
        n_o = defaultdict(lambda: 0) # n_o[i] = number of times oracle has generated
                                     # transition to state i
        states_so_far = set()
        symbols_so_far = set()
        K = len(set(sequence.state_sequence))
        print K
        for t in range(len(sequence)):
            if t == 0:
                prev_state = None
            else:
                prev_state = sequence[t - 1].state
            if t == len(sequence) - 1:
                next_state = None
            else:
                next_state = sequence[t + 1].state
            old_state = sequence[t].state
            symbol = sequence[t].emission.symbol
            # TODO: oracle values should be sampled probably
            state_oracle = \
                bool(np.random.binomial(1,
                                        beta / (np.sum(n[prev_state].values()) + beta - n[prev_state][old_state])
                ))
            emission_oracle = \
                bool(np.random.binomial(1,
                                        beta_e / (np.sum(m[prev_state].values()) + beta_e - m[prev_state][symbol])
                ))
            next_state_oracle = \
                bool(np.random.binomial(1,
                                         beta / (np.sum(m[old_state].values()) + beta)
                ))
            def p_state_given_prev(state, prev_state, oracle):
                """
                Return probability of state given previous state and whether state
                was generated by oracle
                """
                if oracle:
                    denom = np.sum(n_o.values()) + gamma
                    if state in n_o.keys(): # state was represented
                        return n_o[state] / denom
                    else: # state was new
                        return gamma / denom
                else:
                    return n[prev_state][state] / (np.sum(n[prev_state].values()) + beta)
            def p_emission_given_state(state, symbol, oracle):
                if oracle:
                    denom = np.sum(m_o.values()) + gamma_e
                    if symbol in symbols_so_far:
                        return m_o[symbol] / denom
                    else:
                        return gamma_e / denom
                else:
                    return m[state][symbol] / (np.sum(m[state].values()) + beta_e)
            def p(state):
                p_1 = p_state_given_prev(state, prev_state, state_oracle)
                p_2 = p_state_given_prev(next_state, state, next_state_oracle)
                p_3 = p_emission_given_state(state, symbol, emission_oracle)
                return p_1 * p_2 * p_3
            pseudo_state = state_factory.get_state()
            if state_oracle:
                pseudo_states = states_so_far.union(set([pseudo_state]))
            new_state = metropolis(p, old_state, pseudo_states)
            if prev_state != None:
                n[prev_state][new_state] += 1
                n[prev_state][old_state] -= 1
            if next_state != None:
                n[new_state][next_state] += 1
            #m[old_state][symbol] -= 1
            m[new_state][symbol] += 1
            if state_oracle:
                n_o[new_state] += 1
            if emission_oracle:
                m_o[symbol] += 1
            states_so_far = set(map(lambda x: x.state, sequence[:t + 1]))
            symbols_so_far = set(map(lambda x: x.emission.symbol, sequence[:t + 1]))
            sequence[t].state = new_state

def test_asc_desc():
    """
    Build an EmissionSequence of thirty concatenated copies of ABCDEFEDCB
    and train an iHMM thereupon. The resulting HMM should have 10 states.
    """
    symbols_string = 'ABCDEF'
    symbols = map(Symbol, symbols_string)
    emissions = EmissionSequence()
    for i in range(30):
        emissions.extend(map(Emission, symbols))
        emissions.extend(map(Emission, reversed(symbols[1:-1])))
    ihmm = learn_state_sequence(emissions, 2)

def main():
    state_factory = StateFactory(10, 5, 5, 1, 5)
    sequence_factory = SequenceFactory(state_factory)
    print '\n'.join(map(str, sequence_factory.create_sequence(800)))
    test_asc_desc()

if __name__ == '__main__':
    main()