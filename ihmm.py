from __future__ import division
from collections import defaultdict
import math
import numpy as np

__author__ = 'jpaton'

burn_in_period = 1000

class Symbol(object):
    _next_id = 0
    def __init__(self):
        self.id = Symbol._next_id
        Symbol._next_id += 1

    def __repr__(self):
        return repr(self.id)

class StateFactory(object):
    def __init__(self, alpha, beta, gamma, beta_e, gamma_e):
        self.alpha = alpha
        self.beta = beta
        self.gamma = gamma
        self.beta_e = beta_e
        self.gamma_e = gamma_e
        self.next_id = 0

    def get_state(self, *args, **kwargs):
        ret = StateFactory.State(self.alpha,
                                  self.beta_e,
                                  self.gamma_e,
                                  self.next_id,
                                  *args,
                                  **kwargs)
        self.next_id += 1
        return ret

    def generate_state(self, prev_state, states, n_o):
        """
        Generate another state given the previous state.

        Automatically increments n_o[state] if new state is generated by the oracle.
        """
        pseudo_state = self.get_state()
        pseudo_states = states + [pseudo_state]
        denominator = prev_state.total_transitions + self.beta
        def p_nonoracle(state):
            if state == pseudo_state:
                return self.beta / denominator
            return prev_state.transitions[state] / denominator
        probs = map(p_nonoracle, pseudo_states)
        index = np.random.multinomial(1, probs).tolist().index(1)
        if index == len(states):
            # go to oracle
            def p_oracle(state):
                oracle_denom = np.sum(n_o.values()) + self.gamma
                if state == pseudo_state:
                    return self.gamma / oracle_denom
                return n_o[state] / oracle_denom
            probs = map(p_oracle, pseudo_states)
            index = np.random.multinomial(1, probs).tolist().index(1)
            if index == len(states):
                # new state
                n_o[pseudo_state] = 1
                prev_state.transitions[pseudo_state] = 1
                states.append(pseudo_state)
                return pseudo_state
            else:
                n_o[states[index]] += 1
        prev_state.transitions[states[index]] += 1
        return states[index]

    class State(object):
        def __init__(self, alpha, beta_e, gamma_e, id):
            self.transitions = defaultdict(lambda: 0)
            self.emissions = defaultdict(lambda: 0)
            self.beta_e = beta_e
            self.gamma_e = gamma_e
            self.id = id
            self.transitions[self] = alpha

        def __repr__(self):
            return repr(self.id)

        @property
        def total_emissions(self):
            # TODO: memoize this
            return np.sum(self.emissions.values())

        @property
        def total_transitions(self):
            # TODO: memoize
            return np.sum(self.transitions.values())

        def generate_emission(self, symbols, m_o):
            """
            Automatically increments m_o[emission] if emission is generated by the oracle
            """
            pseudo_symbol = Symbol()
            pseudo_symbols = symbols + [pseudo_symbol]
            denominator = self.total_emissions + self.beta_e
            def p_nonoracle(symbol):
                if symbol == pseudo_symbol:
                    return self.beta_e / denominator
                return self.emissions[symbol] / denominator
            probs = map(p_nonoracle, pseudo_symbols)
            index = np.random.multinomial(1, probs).tolist().index(1)
            if index == len(symbols):
                # go to oracle
                def p_oracle(symbol):
                    oracle_denom = np.sum(m_o.values()) + self.gamma_e
                    if symbol == pseudo_symbol:
                        return self.gamma_e / oracle_denom
                    return m_o[symbol] / oracle_denom
                probs = map(p_oracle, pseudo_symbols)
                index = np.random.multinomial(1, probs).tolist().index(1)
                if index == len(symbols):
                    m_o[pseudo_symbol] = 1
                    symbols.append(pseudo_symbol)
                    self.emissions[pseudo_symbol] = 1
                    return pseudo_symbol
                else:
                    m_o[symbols[index]] += 1
            self.emissions[symbols[index]] += 1
            return symbols[index]

class Emission(object):
    def __init__(self, symbol, is_oracle=False):
        self.symbol = symbol
        self.is_oracle = is_oracle

class HMM(defaultdict):
    def __init__(self):
        # self.trans: transmission counts
        super(HMM, self).__init__(lambda: defaultdict(0))
        # self.start_state = State()
        self._transition_count = None
        self._emission_count = None

    def __str__(self):
        for state in self.keys():
            print ',\t'.join([count for count in self[state].values()])

    @property
    def total_transmissions(self):
        if self._transition_count == None:
            # recompute transition count
            self._transition_count = 0
            for state_i in self:
                for state_j in self:
                    if state_i == state_j:
                        continue
                    self._transition_count += self[state_i][state_j]
        return self._transition_count

    @property
    def total_emissions(self):
        if self._emission_count == None:
            # recompute emission count
            self._emission_count = 0
            for state in self:
                for symbol, count in state.iteritems():
                    self._emission_count += count
        return self._emission_count

    def logprob_states(self, states):
        """
        states: a sequence of states, the first state being the start state
        """
        logprob = 0
        for i in range(len(states) - 1):
            state_i, state_j = states[i], states[i + 1]
            logprob += math.log(self[state_i][state_j] / self.total_transitions)
        return logprob

    def logprob_emissions(self, emissions):
        raise NotImplementedError()

    def logprob_both(self, states, emissions):
        return self.logprob_states(states) + self.logprob_emissions(emissions)

    def logprob(self, states = None, emissions = None):
        if states != None and emissions == None:
            return self.logprob_states(states)
        elif states == None and emissions != None:
            return self.logprob_emissions(emissions)
        else:
            return self.logprob_both(states, emissions)

    def generate_states(self, n):
        """
        Returns a state sequence of length n
        """
        raise NotImplementedError()

    def generate_emissions(self, n, states = None):
        """
        Returns an emission sequence of length n
        """
        if states == None:
            states = self.generate_states(n)
        emissions = EmissionSequence()
        emissions.append(self.start_state)
        for state in states[1:]:    # omit start state
            emissions.append(state.generate_emission())
        return emissions

class EmissionSequence(list):
    pass

class StateSequence(list):
    pass

class Sequence(object):
    def __init__(self, states=StateSequence(), emissions=EmissionSequence()):
        self.emissions = emissions
        self.states = states

class SequenceFactory(object):
    def __init__(self, state_factory):
        self.state_factory = state_factory

    def create_sequence(self, n):
        """
        Creates and returns a Sequence of length n given the parameters
        """
        m_o = defaultdict(lambda: 0)                # number of times emission oracle has generated each symbol
        n_o = defaultdict(lambda: 0)                # number of times state oracle has generated each state
        state_sequence = StateSequence()
        emissions = EmissionSequence()
        symbols = list()
        states = list()
        prev_state = self.state_factory.get_state()
        states.append(prev_state)
        n_o[prev_state] = 1
        state_sequence.append(prev_state)
        emissions.append(prev_state.generate_emission(symbols, m_o))
        for i in range(1, n):
            # sample a new state
            next_state = self.state_factory.generate_state(prev_state, states, n_o)
            next_emission = next_state.generate_emission(symbols, m_o)
            state_sequence.append(next_state)
            emissions.append(next_emission)
            prev_state = next_state
        return state_sequence, emissions

def main():
    state_factory = StateFactory(1, 5, 5, 5, 5)
    sequence_factory = SequenceFactory(state_factory)
    print '\n'.join(map(str, sequence_factory.create_sequence(800)))

if __name__ == '__main__':
    main()