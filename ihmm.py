from __future__ import division
from collections import defaultdict
import math
import numpy as np

__author__ = 'jpaton'

burn_in_period = 1000

class Symbol(object):
    _next_id = 0
    def __init__(self, id=None):
        if id == None:
            id = Symbol._next_id
            Symbol._next_id += 1
        self.id = id

    def __repr__(self):
        return repr(self.id)

class StateFactory(object):
    def __init__(self, alpha, beta, gamma, beta_e, gamma_e):
        self.alpha = alpha
        self.beta = beta
        self.gamma = gamma
        self.beta_e = beta_e
        self.gamma_e = gamma_e
        self.next_id = 0

    def get_state(self):
        ret = StateFactory.State(self.alpha,
                                  self.beta_e,
                                  self.gamma_e,
                                  self.next_id)
        self.next_id += 1
        return ret

    def generate_state(self, prev_state, states, n_o):
        """
        Generate another state given the previous state.

        Automatically increments n_o[state] if new state is generated by the oracle.
        """
        pseudo_state = self.get_state()
        pseudo_states = states + [pseudo_state]
        denominator = prev_state.total_transitions + self.beta
        def p_nonoracle(state):
            if state == pseudo_state:
                return self.beta / denominator
            return prev_state.transitions[state] / denominator
        probs = map(p_nonoracle, pseudo_states)
        index = np.random.multinomial(1, probs).tolist().index(1)
        if index == len(states):
            # go to oracle
            def p_oracle(state):
                oracle_denom = np.sum(n_o.values()) + self.gamma
                if state == pseudo_state:
                    return self.gamma / oracle_denom
                return n_o[state] / oracle_denom
            probs = map(p_oracle, pseudo_states)
            index = np.random.multinomial(1, probs).tolist().index(1)
            if index == len(states):
                # new state
                n_o[pseudo_state] = 1
                prev_state.transitions[pseudo_state] = 1
                states.append(pseudo_state)
                return pseudo_state
            else:
                n_o[states[index]] += 1
        prev_state.transitions[states[index]] += 1
        return states[index]

    class State(object):
        def __init__(self, alpha, beta_e, gamma_e, id):
            self.transitions = defaultdict(lambda: 0)
            self.emissions = defaultdict(lambda: 0)
            self.beta_e = beta_e
            self.gamma_e = gamma_e
            self.id = id
            self.transitions[self] = alpha

        def __repr__(self):
            return repr(self.id)

        @property
        def total_emissions(self):
            # TODO: memoize this
            return np.sum(self.emissions.values())

        @property
        def total_transitions(self):
            # TODO: memoize
            return np.sum(self.transitions.values())

        def generate_emission(self, symbols, m_o):
            """
            Automatically increments m_o[emission] if emission is generated by the oracle
            """
            pseudo_symbol = Symbol()
            pseudo_symbols = symbols + [pseudo_symbol]
            denominator = self.total_emissions + self.beta_e
            def p_nonoracle(symbol):
                if symbol == pseudo_symbol:
                    return self.beta_e / denominator
                return self.emissions[symbol] / denominator
            probs = map(p_nonoracle, pseudo_symbols)
            index = np.random.multinomial(1, probs).tolist().index(1)
            if index == len(symbols):
                # go to oracle
                def p_oracle(symbol):
                    oracle_denom = np.sum(m_o.values()) + self.gamma_e
                    if symbol == pseudo_symbol:
                        return self.gamma_e / oracle_denom
                    return m_o[symbol] / oracle_denom
                probs = map(p_oracle, pseudo_symbols)
                index = np.random.multinomial(1, probs).tolist().index(1)
                if index == len(symbols):
                    m_o[pseudo_symbol] = 1
                    symbols.append(pseudo_symbol)
                    self.emissions[pseudo_symbol] = 1
                    return pseudo_symbol
                else:
                    m_o[symbols[index]] += 1
            self.emissions[symbols[index]] += 1
            return symbols[index]

class Emission(object):
    def __init__(self, symbol, is_oracle=False):
        self.symbol = symbol
        self.is_oracle = is_oracle

    def __repr__(self):
        return repr(self.symbol)

class EmissionSequence(list):
    pass

class StateSequence(list):
    pass

class Sequence(object):
    def __init__(self, states=StateSequence(), emissions=EmissionSequence()):
        self.emissions = emissions
        self.states = states

class SequenceFactory(object):
    def __init__(self, state_factory):
        self.state_factory = state_factory

    def create_sequence(self, n):
        """
        Creates and returns a Sequence of length n given the parameters
        """
        m_o = defaultdict(lambda: 0)                # number of times emission oracle has generated each symbol
        n_o = defaultdict(lambda: 0)                # number of times state oracle has generated each state
        state_sequence = StateSequence()
        emissions = EmissionSequence()
        symbols = list()
        states = list()
        prev_state = self.state_factory.get_state()
        states.append(prev_state)
        n_o[prev_state] = 1
        state_sequence.append(prev_state)
        emissions.append(prev_state.generate_emission(symbols, m_o))
        for i in range(1, n):
            # sample a new state
            next_state = self.state_factory.generate_state(prev_state, states, n_o)
            next_emission = next_state.generate_emission(symbols, m_o)
            state_sequence.append(next_state)
            emissions.append(next_emission)
            prev_state = next_state
        return state_sequence, emissions

def draw_categorical(seq, probs):
    index = np.random.multinomial(1, probs).tolist().index(1)
    return list(seq)[index]

class SequenceMember(object):
    def __init__(self, state, emission, state_oracle, emission_oracle):
        self.state = state
        self.emission = emission
        self.state_oracle = state_oracle
        self.emission_oracle = emission_oracle

    def __repr__(self):
        return '(%s, %s, %s, %s)' % (self.state, self.emission, self.state_oracle, self.emission_oracle)

class Sequence(list):
    @property
    def state_sequence(self):
        return map(lambda x: x.state, self)

    @property
    def emission_sequence(self):
        return map(lambda x: x.emission, self)

def ihmm_prob_state(new_stat, prev_state, next_state, emission, n, m):
    pass

def metropolis(p, cur, seq, q = None):
    p_cur = p(cur)
    while True:
        if q == None:
            new = draw_categorical(seq, [1 / len(seq) for i in seq])
        else:
            new = q()
        p_new = p(new)
        if p_new > 0 or p_cur > 0:
            break
    if p_cur == 0:
        return new
    elif p_new == 0:
        return cur
    r = np.min([p_new / p_cur, 1])
    if np.random.binomial(1, r):
        return new
    else:
        return cur

def generate_state(prev_state, states, n, n_o, beta, gamma):
    # first, choose oracle or not
    p_oracle = beta / (np.sum(n[prev_state].values()) + beta)
    is_oracle = np.random.binomial(1, p_oracle)
    if is_oracle:
        denom = np.sum(n_o.values()) + gamma
        def prob(state):
            return n_o[state] / denom
        probs = map(prob, states) + [gamma / denom]
        return draw_categorical(states + [None], probs)
    else:
        denom = np.sum(n[prev_state].values()) + beta
        def prob(state):
            return n[prev_state][state] / denom
        probs = map(prob, states)
        # print probs
        return draw_categorical(states, probs)

def learn_state_sequence(emissions, K=20):
    # first, initialize sequence
    alpha, beta, gamma, beta_e, gamma_e = 1, 1, 1, 1, 1
    state_factory = StateFactory(alpha, beta, gamma, beta_e, gamma_e)
    states = [state_factory.get_state() for i in range(K)]
    sequence = Sequence()   # list of SequenceMember objects
    for symbol in emissions:
        state = draw_categorical(states, [1/K for state in states])
        state_oracle, emission_oracle = True, True
        sequence.append(SequenceMember(state, symbol, state_oracle, emission_oracle))
        # state_oracle = draw_categorical([True, False], [0.5, 0.5])
        # emission_oracle = draw_categorical([True, False], [0.5, 0.5])

    # now that we have our initial state sequence, start Gibbs sampling to improve
    while True:
        state_factory = StateFactory(alpha, beta, gamma, beta_e, gamma_e)
        m = defaultdict(lambda: defaultdict(lambda: 0)) # m[i][j] = number of times state i
                                                        # has emitted symbol j
        n = defaultdict(lambda: defaultdict(lambda: 0)) # n[i][j] = number of times state i
                                                        # has transitioned to state j
        m_o = defaultdict(lambda: 0) # m_o[i] = number of times oracle has generated
                                     # emission i
        n_o = defaultdict(lambda: 0) # n_o[i] = number of times oracle has generated
                                     # transition to state i
        states_so_far = set()
        symbols_so_far = set()
        K = len(set(sequence.state_sequence))
        print K
        for t in range(len(sequence)):
            # print '    ' + repr(sequence[t])
            if t == 0:
                prev_state = None
            else:
                prev_state = sequence[t - 1].state
            if t == len(sequence) - 1:
                next_state = None
            else:
                next_state = sequence[t + 1].state
            old_state = sequence[t].state
            symbol = sequence[t].emission.symbol

            def p_state_given_prev(state, prev_state):
                """
                Return probability of state given previous state and whether state
                was generated by oracle
                """
                denom = np.sum(n_o.values()) + gamma
                multiplier = beta / (np.sum(n[prev_state].values()) + beta)
                if state in states_so_far:  # state was represented
                    left = multiplier * n_o[state] / denom
                else:  # state was new
                    left =  multiplier * gamma / denom
                # TODO: simplify (denominator is being computed twice)
                return left + (n[prev_state][state] / (np.sum(n[prev_state].values()) + beta))

            def p_emission_given_state(state, symbol):
                """
                Return probability of emission given state and whether the emission
                was generated by the oracle
                """
                denom = np.sum(m_o.values()) + gamma_e
                multiplier = beta_e / (np.sum(m[state].values()) + beta_e)
                if symbol in symbols_so_far:
                    left = multiplier * m_o[symbol] / denom
                else:
                    left = multiplier * gamma_e / denom
                return left + (m[state][symbol] / (np.sum(m[state].values()) + beta_e))

            def p(state):
                p_1 = p_state_given_prev(state, prev_state)
                n[prev_state][state] += 1
                # TODO: update count matrices?
                p_2 = p_state_given_prev(next_state, state)
                n[prev_state][state] -= 1
                p_3 = p_emission_given_state(state, symbol)
                return p_1 * p_2 * p_3

            # TODO: maybe the q distribution should really be generated using the
            # generative model...
            # pseudo_state = state_factory.get_state()
            # pseudo_states = states_so_far.union(set([pseudo_state]))
            q = lambda: generate_state(prev_state, list(states_so_far), n, n_o, beta, gamma)
            new_state = metropolis(p, old_state, states_so_far, q)
            if new_state == None:
                new_state = state_factory.get_state()

            # next, sample oracle-ness of state
            if t > 0:
                def p_state_oracle(is_oracle):
                    if n[prev_state][new_state] == 0:
                        return float(is_oracle)
                    if is_oracle:
                        return beta / (np.sum(n[prev_state].values()) + beta)# - n[prev_state][old_state])
                    else:
                        return 1 - beta / (np.sum(n[prev_state].values()) + beta)# - n[prev_state][old_state])
                sequence[t].state_oracle = metropolis(p_state_oracle, sequence[t].state_oracle, [True, False])
            if sequence[t].state_oracle:
                n_o[new_state] += 1

            # next, sample oracle-ness of emission
            if t > 0:
                def p_emission_oracle(is_oracle):
                    if m[new_state][symbol] == 0:
                        return float(is_oracle)
                    if is_oracle:
                        return beta_e / (np.sum(m[new_state].values()) + beta_e)
                    else:
                        return 1 - beta_e / (np.sum(m[new_state].values()) + beta_e)
                sequence[t].emission_oracle = metropolis(p_emission_oracle, sequence[t].emission_oracle, [True, False])
            if sequence[t].emission_oracle:
                m_o[symbol] += 1

            sequence[t].state = new_state
            if new_state not in states_so_far:
                n[new_state][new_state] = alpha
            if prev_state != None:
                n[prev_state][new_state] += 1
            m[new_state][symbol] += 1
            states_so_far = set([i.state for i in sequence[:t + 1]])
            symbols_so_far.add(symbol)
            # states_so_far = states_so_far.union(set([new_state]))
            # symbols_so_far = symbols_so_far.union(set([new_state]))
            sequence[t].state = new_state
            # print ' -> ' + repr(sequence[t])
            # assert (True not in [True in [i < 0 for i in j.values()] for j in n.values()])

def test_asc_desc():
    """
    Build an EmissionSequence of thirty concatenated copies of ABCDEFEDCB
    and train an iHMM thereupon. The resulting HMM should have 10 states.
    """
    symbols_string = 'ABCDEF'
    symbols = map(Symbol, symbols_string)
    emissions = EmissionSequence()
    for i in range(30):
        emissions.extend(map(Emission, symbols))
        emissions.extend(map(Emission, reversed(symbols[1:-1])))
    ihmm = learn_state_sequence(emissions, 20)

def main():
    state_factory = StateFactory(10, 5, 5, 1, 5)
    sequence_factory = SequenceFactory(state_factory)
    print '\n'.join(map(str, sequence_factory.create_sequence(800)))
    test_asc_desc()

if __name__ == '__main__':
    main()